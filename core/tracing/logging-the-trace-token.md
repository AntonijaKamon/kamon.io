---
title: Kamon | Core | Documentation
layout: documentation
---

Logging the Trace Token
=======================

There are many benefits that can be derived from logging the trace token from the currently available TraceContext in
your application, let's explore that idea with a simple example: suppose you have a process that involves a couple
actors and you want to make sense of the logs generated by that process. The actors might look like this:

```scala
class UpperCaser extends Actor with ActorLogging {
  val lengthCalculator = context.actorOf(Props[LengthCalculator], "length-calculator")

  def receive = {
    case anyString: String =>
      log.info("Upper casing [{}]", anyString)
      lengthCalculator.forward(anyString.toUpperCase)
  }
}

class LengthCalculator extends Actor with ActorLogging {
  def receive = {
    case anyString: String =>
      log.info("Calculating the length of: [{}]", anyString)
      sender ! anyString.length
  }
}
```

You should feel familiar with that code, there is nothing new there. If we spawn a `UpperCaser` actor and send it five
string messages the log should contain something like this:

```
22:24:07.197 INFO  [undefined][akka://system/user/upper-caser] Upper casing [Hello without context]
22:24:07.198 INFO  [undefined][akka://system/user/upper-caser] Upper casing [Hello without context]
22:24:07.198 INFO  [undefined][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WITHOUT CONTEXT]
22:24:07.199 INFO  [undefined][akka://system/user/upper-caser] Upper casing [Hello without context]
22:24:07.200 INFO  [undefined][akka://system/user/upper-caser] Upper casing [Hello without context]
22:24:07.200 INFO  [undefined][akka://system/user/upper-caser] Upper casing [Hello without context]
22:24:07.204 INFO  [undefined][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WITHOUT CONTEXT]
22:24:07.205 INFO  [undefined][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WITHOUT CONTEXT]
22:24:07.205 INFO  [undefined][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WITHOUT CONTEXT]
22:24:07.206 INFO  [undefined][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WITHOUT CONTEXT]
```

Can you tell which log statement from the `LengthCalculator` actor corresponds to each log statement from `UpperCaser`
actor?, seems easy to figure it out manually in this case, but as the number of events happening concurrently in your
application grows it becomes harder to answer that question without some extra help. Let's see how Kamon can help us in
this situation:

```scala
TraceRecorder.withNewTraceContext("simple-test") {
  upperCaser ! "Hello World with TraceContext"
}
```

When using the `TraceRecorder.withNewTraceContext(..)` method, Kamon will create a new `TraceContext` and make it
available during the execution of the piece of code passed as argument. This time, we are sending a message to an actor
which happens to be one of the situations under which Kamon will automatically propagate a `TraceContext`, so we can
expect the current context to be available to the actor when processing the message we just sent, and
<strong>only</strong> when processing that message. Let's repeat the exercise of sending five messages to this actor,
now doing it with a new `TraceContext` each time and look at the log:

```
22:24:07.223 INFO  [hostname-1][akka://system/user/upper-caser] Upper casing [Hello World with TraceContext]
22:24:07.224 INFO  [hostname-2][akka://system/user/upper-caser] Upper casing [Hello World with TraceContext]
22:24:07.225 INFO  [hostname-1][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WORLD WITH TRACECONTEXT]
22:24:07.225 INFO  [hostname-3][akka://system/user/upper-caser] Upper casing [Hello World with TraceContext]
22:24:07.226 INFO  [hostname-4][akka://system/user/upper-caser] Upper casing [Hello World with TraceContext]
22:24:07.227 INFO  [hostname-5][akka://system/user/upper-caser] Upper casing [Hello World with TraceContext]
22:24:07.227 INFO  [hostname-2][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WORLD WITH TRACECONTEXT]
22:24:07.228 INFO  [hostname-3][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WORLD WITH TRACECONTEXT]
22:24:07.228 INFO  [hostname-4][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WORLD WITH TRACECONTEXT]
22:24:07.229 INFO  [hostname-5][akka://system/user/upper-caser/length-calculator] Calculating the length of: [HELLO WORLD WITH TRACECONTEXT]
```

Can you tell which log statement from `LengthCalculator` corresponds to each log statement from `UpperCaser` now?, it
has become a no-brainer: each `TraceContext` created by Kamon gets a unique trace token that we are including in the log
patterns (the first value between square brackets) and with that small but important piece of information the relation
between each log line is absolutely clear.


Including the Trace Token in your Application Logs
--------------------------------------------------

Kamon provides a very simple way to make sure that the trace token available when the log statement was executed is
included in your logs, no matter if you are logging synchronously or asynchronously. Kamon provides built in support
for logging using Logback, but extending the support to any other logging framework should be a trivial task.

When using Akka's `ActorLogging` all logging events are sent to your actor system's event stream and then picked up by
your registered listeners for actual logging. Akka captures the actor, thread and timestamp from the instant in which
the event was generated and makes that info available when performing the actual logging. As an addition to this, Kamon
captures the `TraceContext` that is present when creating the log events and makes it available when the actual logging
is performed. If you are using the loggers directly then the `TraceContext` should be already available.

`TraceRecorder.currentContext` gives you access to the currently `TraceContext`, so the following expression gives you
the trace token for the currently available context:

```scala
TraceRecorder.currentContext.map(_.token)
```

Kamon already packs a Logback converter that you can register in your `logback.xml` configuration file and use in your
logging patterns as show bellow:

```xml
<configuration scan="true">
  <conversionRule conversionWord="traceToken" converterClass="kamon.trace.logging.LogbackTraceTokenConverter"/>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%date{HH:mm:ss.SSS} %-5level [%traceToken][%X{akkaSource}] %msg%n</pattern>
    </encoder>
  </appender>

  <root level="debug">
    <appender-ref ref="STDOUT" />
  </root>

</configuration>
```
